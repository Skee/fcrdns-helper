#!/usr/bin/perl -w

# fcrdns-helper - worker
# this script acts as a pdns pipe backend worker
#
# will respond to any PTR queries with a hostname generated by replacing the bytes in the IP
# with the words in the PGP word list and adding a suffix
# This requires Encode::Wordlist::PGP (perl -MCPAN -e install Encode::Wordlist::PGP).
#
# Will also respond to A queries for hostnames in the zone used by PTRs, to complete the 
# full-circle DNS loop. This requires you delegate a zone/subdomain to the same box that
# generates the PTRs.
#
# The zone I use is static.reverse.newhost.ro, the NS for newhost.ro has this added to the zone:
# static.reverse    IN  NS  ns5.newhost.ro.
#
# Also supported: static PTRs, because not all customers want random words in their hostname.
# Just edit the %staticdns hash. TODO: sqlite db support and webapp for configuring staticdns.
#
# Written by Mircea Suciu for NewHOST.ro. Email me at: my_first_name @ that_domain <--.ro
# Licensed as WTFPL: http://sam.zoy.org/wtfpl/

use warnings;
use strict;
use Encode::Wordlist::PGP qw(:all);


# turn off buffering
$|=1;


# these never change - array of statically assigned PTRs
my %staticdns;
$staticdns{"178.157.80.3"}      = "server.selenis.ro";
$staticdns{"188.119.144.21"}    = "serv1.solidhost.ro";
$staticdns{"188.119.152.37"}    = "mirage.token.ro";


# converts dotted-quad IPs to their decimal form
sub ip2long {
        my $address = shift;
        my ($a, $b, $c, $d) = split '\.', $address;
        my $decimal = $d + ($c * 256) + ($b * 256**2) + ($a * 256**3);
        return $decimal;
}


# converts IPs in decimal form back to dotted quad
sub long2ip {
    my $address = shift;
    my $d = $address % 256; $address -= $d; $address /= 256;
    my $c = $address % 256; $address -= $c; $address /= 256;
    my $b = $address % 256; $address -= $b; $address /= 256;
    my $a = $address;
    my $dotted="$a.$b.$c.$d";
    return $dotted;
}


# generates hostname for PTR by replacing each byte in the IP with the appropriate word in the PGP word list
sub get_reverse {
        my $ip_address = shift;
        $ip_address =~ s/\.in-addr\.arpa//;
        my @reversed = split(/\./, $ip_address);
        $ip_address = "$reversed[3].$reversed[2].$reversed[1].$reversed[0]";
	print STDERR "Reversed IP for PTR: $ip_address\n";
        if (exists $staticdns{$ip_address}) {
            return $staticdns{$ip_address}.".";
        }
        my $ip_dec = ip2long($ip_address);
        my $revname = join('-', pgp_wordlist_encode(sprintf("%08x", $ip_dec))) . ".static.reverse.newhost.ro.";
        return $revname;

}


# turns a hostname in the assigned zone back into an IP address by reversing the PGP word list "encoding"
sub get_forward {
        my $wordlist = shift;
        $wordlist =~ s/-/ /g;
        $wordlist =~ s/\.static\.reverse\.newhost\.ro//i;
	my @words2arr = pgp_wordlist_decode($wordlist);
        my $ip =  long2ip(hex(join('', @words2arr)));
        return $ip;
}


# debug
#print get_reverse(shift(@ARGV)) . "\n";


# start reading
my $line=<>;
chomp($line);


# say hello to pdns
unless($line eq "HELO\t1") {
    print "FAIL\n";
    print STDERR "Recevied '$line'\n";
    <>;
    exit;
}
print "OK\tNewHOST PTR manager is up\n";


# loop-de-loop
while(<>)
{
    print STDERR "$$ Received: $_";
    chomp();
    my @arr=split(/\t/);
    if(@arr<6) {
        print "LOG  PowerDNS sent unparseable line - @arr\n";
        print "FAIL\n";
        next;
    }

    my ($type,$qname,$qclass,$qtype,$id,$ip)=split(/\t/);


    # respond to PTR or ANY queries for a reversed, in-addr IP address
    if(($qtype eq "PTR" || $qtype eq "ANY") && $qname =~ /\d+\.\d+\.\d+\.\d+\.in-addr\.arpa$/i) {
        print "DATA\t$qname\t$qclass\tPTR\t14400\t1\t".get_reverse($qname)."\n";
    }


    # respond to A and ANY lookups for hostnames generated by get_reverse (.static.reverse.newhost.ro)
    elsif(($qtype eq "A" || $qtype eq "ANY") && $qname =~ /\.static\.reverse\.newhost\.ro$/i) {
        print "DATA\t$qname\t$qclass\tA\t14400\t1\t".get_forward($qname)."\n";
    }

    # dump out a basic SOA if anyone asks
    elsif($qtype eq "SOA") {
        print "DATA\t$qname\t$qclass\tSOA\t10800\t1\tns5.newhost.ro.\ttech.newhost.ro.\t1293180941\t10800\t3600\t604800\t38400\n";
    }


    # also dump out a basic NS record if anyone cares
    elsif($qtype eq "NS" && $qname eq "static.reverse.newhost.ro") {
        print "DATA\t$qname\t$qclass\tNS\t10800\t1\tns5.newhost.ro.\n";
        print "DATA\t$qname\t$qclass\tNS\t10800\t1\tns6.newhost.ro.\n";
    }


    # pdns has sent something we aren't prepared for
    else {
        print "FAIL\n";
        next;
    }
    print "END\n";
}

# I DON'T EVEN SPEAK PERL!
